#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <math.h>
#include <time.h>
#include <pthread.h>


// todo:
/* использование
 * vortex -h [H] -d ['[+|-](x1;y1) [+|-](x2;y2) ... координаты']
 * но вообще, формат
 * vortex -h [%f] -d ['[+|-] %f %f [+|-] %f %f ... координаты']
 */
// todo:
/* коды возврата
 * номер	-- описание
 */


/* настройки */
#define EF	2.07e-7		// Ф0	: Гс/см^2	// квант изменения магнитного поля


// параметры образца
#define TC	84.0		// Tc	: K		// критическая температура
double tc = TC / 11606;		// Tc	: эВ		// критическая температура в Эв

#define L0	1.8e-5		// λ0	: см		// глубина проникновения при температуре T = 0 K
#define L	L0 * pow(1 - pow(t / tc, 3.3), -0.5)	// λ(T) : см	// глубина проникновения

#define K0	2e-7		// ξ0	: см		// длина когерентности при температуре T = 0 K
#define K	K0 * pow(1 - pow(t / tc, 3.3), -0.5)	// ξ(T) : см	// длинна когерентности

//#define DD	2.7e-7		// δ	: см		// толщина слоя (условно по координите Z)
#define DD	2.7e-7		// δ	: см		// толщина слоя (условно по координите Z)

#define U01	0.1		// U0	: эВ		// верхниий предел в распределении потенциалов дефектов
#define U02	0.0		// U0	: эВ		// нижний предел в распределении потенциалов дефектов

// размеры
#define X	1.8e-4		// ширина (10 * L0)	: см
//#define X	3e-4		// ширина		: см
#define Y	5e-4		// высота		: см



// todo: I
// распределение тока (если ток доступен)
//#define I	400		// I	: 


// распределение поля
//#define DISPX	2 * X / 9
//#define DISPY	2 * Y / 9
//#define MATHX	X / 2
//#define MATHY	Y / 2
//#define NORM	400.0
//#define PLUS	300.0
//#define H	exp(-((x - MATHX) * (x - MATHX) / (DISPX * DISPX) + (y - MATHY) * (y - MATHY) / (DISPY * DISPY)) / 2) / (2 * M_PI * DISPX * DISPY) / 12891550.390444 * NORM + PLUS


// todo: I
// постоянное поле
#define H0	0		// H	: Гс	// начальное значение поля
#define HE	1200		// H	: Гс	// крайние значения полей
#define HI	100		// H	: Гс	// значение на которое изменяется поле во время расчёта

double he = 1200;			// H	: Гс		// поле, изменяющееся во время расчёта

// поле, связанное с током
double hi = 0;			// Hi	: эрстед


//double hc = EF / (2 * pow(2, 0.5) * M_PI * L0 * K0);		// Hc	: Гс		// критическое поле при нулевой температуре
//double hc = EF / (2 * M_PI * L0);		// Hc	: Гс		// критическое поле при нулевой температуре
double hc = 290;


// распределение температуры
// Гаусс
//#define DISPX	2 * X / 9
//#define DISPY	2 * Y / 9
//#define MATHX	X / 2
//#define MATHY	Y / 2
//#define NORM	60.0 / 11606
//#define T	exp(-((x - MATHX) * (x - MATHX) / (DISPX * DISPX) + (y - MATHY) * (y - MATHY) / (DISPY * DISPY)) / 2) / (2 * M_PI * DISPX * DISPY) / 12891550.390444 * NORM

// Гаусс МИФИ
//#define DISPX	2 * X / 11
//#define DISPY	2 * Y / 3
//#define MATHX	X / 2
//#define MATHY	Y / 2
//#define NORM	80.0 / 11606
////#define T	exp(-((x - MATHX) * (x - MATHX) / (DISPX * DISPX) + (y - MATHY) * (y - MATHY) / (DISPY * DISPY)) / 2) / (2 * M_PI * DISPX * DISPY) // / 12891550.390444 * NORM
//#define T	exp(-((x - MATHX) * (x - MATHX) / (DISPX * DISPX) + (y - MATHY) * (y - MATHY) / (DISPY * DISPY)) / 2) / (2 * M_PI * DISPX * DISPY) / 5252113.1220325464382768 * NORM

// Гаусс X
//#define DISPX	2 * X / 9
//#define MATHX	X / 2
//#define NORM	60.0 / 11606
//#define T	exp(-((x - MATHX) * (x - MATHX) / (DISPX * DISPX)) / 2) / (pow(2 * M_PI,0.5) * DISPX) / 3590.4805236128945580 * NORM

// Гаусс Y (Y = 5e-4) // 0 + 0.7
//#define DISPY	5e-4 / 14
//#define MATHY	Y / 2
//#define NORM	69.3 / 11606
//#define T	exp(-((y - MATHY) * (y - MATHY) / (DISPY * DISPY)) / 2) / (pow(2 * M_PI,0.5) * DISPY) * NORM / 11170.3838512401162006 + 0.7 / 11170.3838512401162006

// Гаусс Y (Y = 5e-4) // 0.5
//#define DISPY	13 * 5e-4 / 80
//#define MATHY	Y / 2
//#define NORM	70.0 / 11606
//#define T	exp(-((y - MATHY) * (y - MATHY) / (DISPY * DISPY)) / 2) / (pow(2 * M_PI,0.5) * DISPY) * NORM / 4910.0588357099413770

// линейная температура
//#define T	(1 - x / X) * 40.0 / 11606	// T	: K

//#define T	(x / X * 39.0 + 1) / 11606	// T	: K
//#define T	(x / X * 49.0 + 1) / 11606	// T	: K
#define T	(x / X * 59.0 + 1) / 11606	// T	: K
//#define T	(x / X * 79.0 + 1) / 11606	// T	: K

// постоянная температура
//#define T	60.0 / 11606	// T	: K


// формулы расчёта энергий
double m1 = -EF / (4 * M_PI) * DD / (1.6 * 1e-12);
//double m11 = - 2 * M_PI * I / (1.6 * 1e-12 * 3 * 1e10); // todo: I
#define E1	m1 * h		// E1(H,λ,x,y)	: эВ	энергия от магнитного поля если все границы переодичны
#define E1X	m1 * (h * (1 - cosh((x - (X / 2)) / l) / cosh(X / (2 * l))) + hi * (sinh((x - (X / 2)) / l) / sinh(X / (2 * l)) + ((x > X / 2) ? -1 : 1) ))		// E1(H,λ,x,y)	: эВ	энергия от магнитного поля если границы не периодичны по X
#define E1Y	m1 * (h * (1 - cosh((y - (Y / 2)) / l) / cosh(Y / (2 * l))) + hi * (sinh((y - (Y / 2)) / l) / sinh(Y / (2 * l)) + ((y > Y / 2) ? -1 : 1) ))		// E1(H,λ,x,y)	: эВ	энергия от магнитного поля если границы не периодичны по Y
// todo: передалать энергию от магнитного поля
#define E1XY	m1 * h		// E1(H,λ,x)	: эВ	энергия от магнитного поля, если все границы не переодичны

double m2 = (EF * EF / (16 * M_PI * M_PI)) * DD / (1.6 * 1e-12);
#define E2	m2 * (log(l / xi) + 0.52) / (l * l)		// E2(λ,ξ)	: эВ	// собственная энергия вихря

double m3 = (EF * EF / (16 * M_PI * M_PI)) * DD / (1.6 * 1e-12);
#define E3	m3 * bessk(0, r / l) / (l * l)		// E3(r,λ) 	: эВ	// энергия взаимодействия типа вихрь-вихрь	: (194)

#define E4	-u * exp(-r / (2 * xi)) / (r / xi + 1)		// E4(r,ξ)	: эВ	// энергия взаимодействия типа примесь-вихрь


// примеси
#define NP	0		// количество примесей	: штук
#define RP	0.04		// отвечает за хаотичность примесей	: безразм. (чем коэфициент меньше, тем упорядоченней будут вести себя вихри)
#define CP	1		// 0 - считать взаимодействие всех примесей с вихрем; 1 - считать взаимодействие ТОЛЬКО ближайшей примеси с вихрем


// расстояния
#define DP	0.1		// максимальный радиус перемещения вихря (от λ)	: см
#define DS	10 * K0	// максимальное расстояние на котором допустима аннигиляция	: см
#define DR	K0		// минимальное расстояние на которое подходят вихри	: см
#define BRN	L0		// максимальное расстояние от стенки, на котором рождаются вихри	: см
#define DRN	0.4 * L0	// минимальное расстояние от стенки, на котором рождаются вихри	: см

#define TA	1		// τ (коэффициент для подкручивания вероятности)


// шаги
#define D	-1		// длина времени измерений (сколько програмных шагов в одном физическом); при -1 будет пытаться ориентироваться на количество вихрей (ЭТО НЕ БУДЕТ ФИКСИРОВАННАЯ ВЕЛИЧИНА)
#define DM	40		// минимальное колличество програмных шагов в одном физическом (используется если D == -1)
#define ST	8		// максимальное колличество программных шагов, которое выполяет ядро (при -1 неограничено) // fail: не работает
#define RND	4		// коэффициент, определяющий вероятность выбора действия в програмном шаге (добавить, убрать, передвинуть)


// fail: не работает
/*
#define EE	1		// определяет то, как считать стационарные энергии (E1 + E2 + E4), если 0, то будет БЫСТРО брать ПРИБЛИЖЁННЫЕ значения из массива, если 1, то будет МЕДЛЕННО высчитывать ТОЧНЫЕ значения в течение всего расчсёт
unsigned long long ex = (int) (X / (K0 / 4)),	// количество разбиений системы по направлению X при приближённом расчёте энергиий
	      ey = (int)(Y / (K0 / 4));		// количество разбиений системы по направлению Y при приближённом расчёте энергиий
*/


// границы
#define XG	1		// при 1 границы непереодичны по X
#define YG	0		// при 1 границы непереодичны по Y

// выход из программы, погрешность
#define N	1000		// количество физических шагов, которые должна работать программа
/* --- */


// todo:
/* переменные
 * h	-- H	// внешнее магнитное поле	: эрстеды
 * t	-- T	// температура		: эВ
 * r	-- r	// расстояние			: см
 * x	-- x	// координата по х		: см
 * y	-- y	// координата по у		: см
 * l	-- λ	// глубина проникновения	: см
 * xi	-- ξ	// длинна когерентности	: см
 */


// функции бесселя из bessel.c
extern double bessj(int,double);
extern double bessy(int,double);
extern double bessi(int,double);
extern double bessk(int,double);


struct vortex
{
	double x;	// координата по x
	double y;	// координата по y
	char zn;	// направление вихря (o -- на нас ('+' в энергиях) / x -- в нас ('-' в энергиях))
	double t;	// T, температура в точке
	double h;	// H, поле в точке
	double l;	// λ, глубина проникновения в точке
	double xi;	// ξ, длина когерентности в точке
	double e;	// E1 + E2 + E4, все стационарные энергии
} **v;			// массив, содержащий вихри всего расчёта

struct prim
{
	double x;	// координата по x
	double y;	// координата по y
	double u;	// потенциал дефекта
} *pr;			// массив, содержащий примеси


int *nn;		// массив, содержащий колличество вихрей от физического шага (nn[номер шага] = колличество вихрей)

double *e,		// массив, содержащий полную энергию системы от физического шага (e[номер шага] = энергия)      : эВ
       e0,		// изменение энергии происходящее на каждом програмном шаге
       **ee;		// двумерный массив, хранит примерные значения стационарных энергий (e[x][y] = примерное значение энергии)

unsigned long long k,	// програмные шаги
	      dk = 0,	// количество програмных шагов до записи следующего физического шага (счётчик)
	      nm,	// физические шаги
	      d;	// номер следующего физического шага в програмном понимании


double ue40[] = {-0.122603967977445,-0.245207935954889,-0.356112236146188,-0.456455322853503,-0.547262700948397,-0.629458316846844,-0.703874781347676,-0.771262545849693,-0.832298140636212,-0.887591572460967,-0.937692968437293,-0.983098544090846,-1.02425596526729,-1.06156916628587,-1.09540268020327,-1.12608553121705,-1.15391473401959,-1.17915844024636,-1.20205876798640,-1.22283434658679,-1.24168260563904,-1.25878183404144,-1.27429303235163,-1.28836157924283,-1.30111873072710,-1.31268296888248,-1.32316121509394,-1.33264992127032,-1.34123605111127,-1.34899796225341,-1.35600619900739,-1.36232420439538,-1.36800895929766,-1.37311155570883,-1.37767771037698,-1.38174822444624,-1.38535939413509,-1.38854337695417,-1.39132851749071,-1.39373963635762,-1.39579828551790,-1.39752297284559,-1.39892935846862,-1.40003042515310,-1.40083662472990,-1.40135600232959,-1.40159429997878,-1.40155504091650,-1.40123959581297,-1.40064723191093,-1.39977514596236,-1.39861848169699,-1.39717033243451,-1.39542172933653,-1.39336161568763,-1.39097680749523,-1.38825194060547,-1.38516940444519,-1.38170926241838,-1.37784915890864,-1.37356421276550,-1.36882689708324,-1.36360690501396,-1.35787100129273,-1.35158285909099,-1.34470288175482,-1.33718800892647,-1.32899150649142,-1.32006273973801,-1.31034692906260,-1.29978488750051,-1.28831273931079,-1.27586161879166,-1.26235734845327,-1.24772009562457,-1.23186400652242,-1.21469681676296,-1.19611943724821,-1.17602551431444,-1.15430096298410,-1.13082347211870,-1.10546198022786,-1.07807612064843,-1.04851563476832,-1.01661975193264,-0.982216534634287,-0.945122187559068,-0.905140329025686,-0.862061223334660,-0.815660972517547,-0.765700665959296,-0.711925486352409,-0.654063770432609,-0.591826022942219,-0.524903882269870,-0.452969036224487,-0.375672086418010,-0.292641359755881,-0.203481665567414,-0.107772996950752,-1.206432833409055E-002};
double ue60[] = {-0.121675017422232,-0.243350034844465,-0.353353618819255,-0.452837432910657,-0.542836309422415,-0.624280366050681,-0.698005837369495,-0.764764760025442,-0.825233635228161,-0.880021178545119,-0.929675254947323,-0.974689086335350,-1.01550680925018,-1.05252845200568,-1.08611439294995,-1.11658935486600,-1.14424598456392,-1.16934806141454,-1.19213337385519,-1.21281629869574,-1.23159011431105,-1.24862907547194,-1.26409027459621,-1.27811531155376,-1.29083179179921,-1.30235467050085,-1.31278745845680,-1.32222330391449,-1.33074596291445,-1.33843066944498,-1.34534491550291,-1.35154915009122,-1.35709740523431,-1.36203785624189,-1.36641332269404,-1.37026171594132,-1.37361643830765,-1.37650673864161,-1.37895802837704,-1.38099216183059,-1.38262768407640,-1.38388004939183,-1.38476181295866,-1.38528279822746,-1.38545024210616,-1.38526891991341,-1.38474125184047,-1.38386739249107,-1.38264530491228,-1.38107082039183,-1.37913768517458,-1.37683759514302,-1.37416021941144,-1.37109321370010,-1.36762222428338,-1.36373088324283,-1.35940079570287,-1.35461151968087,-1.34934053914606,-1.34356323085070,-1.33725282547298,-1.33038036359281,-1.32291464700958,-1.31482218590369,-1.30606714234180,-1.29661127062832,-1.28641385501287,-1.27543164527479,-1.26361879072118,-1.25092677315379,-1.23730433938309,-1.22269743389361,-1.20704913229379,-1.19029957621589,-1.17238591036632,-1.15324222246390,-1.13279948684383,-1.11098551254640,-1.08772489675355,-1.06293898448134,-1.03654583548310,-1.00846019936527,-0.978593499966104,-0.946853830095797,-0.913145957784575,-0.877371345233146,-0.839428181706292,-0.799211431655438,-0.756612899399167,-0.711521311730955,-0.663822419860501,-0.613399122128402,-0.560131608962674,-0.503897531569125,-0.444572195865150,-0.382028783177223,-0.316138599225620,-0.246771352914553,-0.173795466431370,-9.707841813371959E-002,-2.036136983606934E-002};
double ue80[] = {-0.120659127350436,-0.241318254700871,-0.350333027612800,-0.448867654844271,-0.537965710013095,-0.618562961017825,-0.691498797132724,-0.757526410427218,-0.817321870278811,-0.871492213947792,-0.920582662215605,-0.965083056739682,-1.00543360485537,-1.04203000789218,-1.07522804051948,-1.10534764106572,-1.13267656605064,-1.15747365623104,-1.17997175619800,-1.20038032489926,-1.21888777032493,-1.23566353792704,-1.25085997909031,-1.26461402308418,-1.27704867336414,-1.28827434681542,-1.29839007251218,-1.30748456477129,-1.31563718368609,-1.32291879490923,-1.32939253919582,-1.33511452109965,-1.34013442522159,-1.34449606752583,-1.34823788845516,-1.35139339387834,-1.35399154928363,-1.35605713208154,-1.35761104639153,-1.35867060425342,-1.35924977681961,-1.35935941874315,-1.35900746867467,-1.35819912851387,-1.35693702382515,-1.35522134761841,-1.35304998951221,-1.35041865213508,-1.34732095647836,-1.34374853778979,-1.33969113348800,-1.33513666448287,-1.33007131120418,-1.32447958556853,-1.31834440005206,-1.31164713498223,-1.30436770511432,-1.29648462651723,-1.28797508475703,-1.27881500533437,-1.26897912730329,-1.25844108097234,-1.24717347056422,-1.23514796268602,-1.22233538143828,-1.20870581096640,-1.19422870623201,-1.17887301275378,-1.16260729603634,-1.14539988137164,-1.12721900465887,-1.10803297484588,-1.08781034854646,-1.06652011733385,-1.04413190814946,-1.02061619719816,-0.995944537625621,-0.970089801189778,-0.943026434046038,-0.914730726664885,-0.885181097790111,-0.854358392226083,-0.822246192112833,-0.788831141208366,-0.754103281548322,-0.718056401694105,-0.680688395611936,-0.642001631047394,-0.602003326073181,-0.560705932292768,-0.518127522979851,-0.474292184224153,-0.429230406938917,-0.382979477365846,-0.335583863490409,-0.287095594556138,-0.237574630642270,-0.187089219047110,-0.135716234001537,-8.354149602584965E-002,-3.136675805016204E-002};
double uec[] = {-0.124279093518172,-0.248558187036345,-0.361080857013170,-0.462958934592466,-0.555199072207485,-0.638712690265640,-0.714324982850124,-0.782783071423352,-0.844763387098552,-0.900878354423440,-0.951682442718013,-0.997677644759463,-1.03931843694890,-1.07701626997105,-1.11114363431885,-1.14203774085431,-1.17000385277293,-1.19531830189484,-1.21823121908636,-1.23896900579116,-1.25773657109214,-1.27471935640832,-1.29008516783271,-1.30398583421627,-1.31655870738159,-1.32792801928969,-1.33820610957014,-1.34749453554354,-1.35588507570464,-1.36346063658119,-1.37029607192948,-1.37645892236067,-1.38201008270639,-1.38700440371768,-1.39149123404261,-1.39551490783797,-1.39911518283290,-1.40232763317319,-1.40518400092767,-1.40771250973010,-1.40993814365554,-1.41188289408683,-1.41356597701036,-1.41500402288836,-1.41621124098366,-1.41719955976077,-1.41797874475046,-1.41855649504252,-1.41893851936006,-1.41912859246716,-1.41912859246716,-1.41893851936006,-1.41855649504252,-1.41797874475046,-1.41719955976077,-1.41621124098366,-1.41500402288836,-1.41356597701036,-1.41188289408683,-1.40993814365554,-1.40771250973010,-1.40518400092767,-1.40232763317319,-1.39911518283290,-1.39551490783797,-1.39149123404261,-1.38700440371768,-1.38201008270639,-1.37645892236067,-1.37029607192948,-1.36346063658119,-1.35588507570464,-1.34749453554354,-1.33820610957014,-1.32792801928969,-1.31655870738159,-1.30398583421627,-1.29008516783271,-1.27471935640832,-1.25773657109213,-1.23896900579116,-1.21823121908636,-1.19531830189484,-1.17000385277293,-1.14203774085431,-1.11114363431885,-1.07701626997105,-1.03931843694890,-0.997677644759463,-0.951682442718012,-0.900878354423440,-0.844763387098552,-0.782783071423352,-0.714324982850124,-0.638712690265639,-0.555199072207485,-0.462958934592466,-0.361080857013170,-0.248558187036345,-0.124279093518172,-0.124279093518172};
double uec40[] = {-9.277552697742930E-002,-0.185551053954859,-0.271839374370210,-0.352092474663755,-0.426730728217983,-0.496145097313431,-0.560699181026328,-0.620731119795169,-0.676555366632554,-0.728464334260012,-0.776729926793686,-0.821604964003991,-0.863324505609647,-0.902107082542876,-0.938155841635230,-0.971659609720045,-1.00279388272538,-1.03172174493840,-1.05859472325641,-1.08355358089917,-1.10672905474006,-1.12824254011824,-1.14820672671901,-1.16672618885315,-1.18389793322704,-1.19981190707314,-1.21455146930205,-1.22819382714451,-1.24081044057016,-1.25246739660171,-1.26322575548504,-1.27314187052859,-1.28226768328734,-1.29065099563764,-1.29833572016799,-1.30536211019736,-1.31176697062591,-1.31758385072254,-1.32284321985919,-1.32757262711229,-1.33179684556745,-1.33553800208325,-1.33881569319381,-1.34164708775732,-1.34404701688818,-1.34602805164373,-1.34760056887269,-1.34877280557006,-1.34955090202332,-1.34993893397579,-1.34993893397579,-1.34955090202332,-1.34877280557006,-1.34760056887269,-1.34602805164373,-1.34404701688818,-1.34164708775732,-1.33881569319381,-1.33553800208325,-1.33179684556745,-1.32757262711229,-1.32284321985919,-1.31758385072254,-1.31176697062591,-1.30536211019736,-1.29833572016799,-1.29065099563764,-1.28226768328734,-1.27314187052859,-1.26322575548504,-1.25246739660171,-1.24081044057016,-1.22819382714451,-1.21455146930205,-1.19981190707314,-1.18389793322704,-1.16672618885315,-1.14820672671901,-1.12824254011824,-1.10672905474006,-1.08355358089917,-1.05859472325641,-1.03172174493840,-1.00279388272538,-0.971659609720045,-0.938155841635230,-0.902107082542875,-0.863324505609647,-0.821604964003990,-0.776729926793686,-0.728464334260012,-0.676555366632554,-0.620731119795169,-0.560699181026328,-0.496145097313431,-0.426730728217983,-0.352092474663755,-0.271839374370210,-0.185551053954858,-9.277552697742902E-002,2.775557561562891E-016};
double uec60[] = {-6.921338437494751E-002,-0.138426768749895,-0.203998565068672,-0.266116121320761,-0.324956916238311,-0.380689066378228,-0.433471806455199,-0.483455944298023,-0.530784291729115,-0.575592072598279,-0.618007309136569,-0.658151187734096,-0.696138405186851,-0.732077496401843,-0.766071144496829,-0.798216474180651,-0.828605329252407,-0.857324535012301,-0.884456146333933,-0.910077682106794,-0.934262346718809,-0.957079239211732,-0.978593550706970,-0.998866750665940,-1.01795676251709,-1.03591812915144,-1.05280216875935,-1.06865712145400,-1.08352828710023,-1.09745815474275,-1.11048652400338,-1.12265061879430,-1.13398519367206,-1.14452263313631,-1.15429304415695,-1.16332434219403,-1.17164233095624,-1.17927077612574,-1.18623147326018,-1.19254431006565,-1.19822732321874,-1.20329674989988,-1.20776707418531,-1.21165106843012,-1.21495982976073,-1.21770281178095,-1.21988785158225,-1.22152119213551,-1.22260750012801,-1.22314987929687,-1.22314987929687,-1.22260750012801,-1.22152119213551,-1.21988785158225,-1.21770281178095,-1.21495982976073,-1.21165106843012,-1.20776707418531,-1.20329674989988,-1.19822732321874,-1.19254431006565,-1.18623147326018,-1.17927077612574,-1.17164233095624,-1.16332434219403,-1.15429304415695,-1.14452263313631,-1.13398519367206,-1.12265061879430,-1.11048652400338,-1.09745815474275,-1.08352828710023,-1.06865712145400,-1.05280216875935,-1.03591812915144,-1.01795676251709,-0.998866750665940,-0.978593550706970,-0.957079239211732,-0.934262346718809,-0.910077682106794,-0.884456146333934,-0.857324535012301,-0.828605329252407,-0.798216474180652,-0.766071144496829,-0.732077496401843,-0.696138405186851,-0.658151187734096,-0.618007309136570,-0.575592072598279,-0.530784291729115,-0.483455944298023,-0.433471806455199,-0.380689066378229,-0.324956916238311,-0.266116121320761,-0.203998565068673,-0.138426768749895,-6.921338437494795E-002,-4.440892098500626E-016};
double uec80[] = {-2.334722087871510E-002,-4.669444175743021E-002,-6.940160162292430E-002,-9.147951340846661E-002,-0.112938690405384,-0.133789351269388,-0.154041424886606,-0.173704555101617,-0.192788105309761,-0.211301162915899,-0.229252543661749,-0.246650795823857,-0.263504204284203,-0.279820794475389,-0.295608336202267,-0.310874347341850,-0.325626097423252,-0.339870611089370,-0.353614671441948,-0.366864823271631,-0.379627376174528,-0.391908407556784,-0.403713765528582,-0.415049071688957,-0.425919723802748,-0.436330898370960,-0.446287553095771,-0.455794429241333,-0.464856053891527,-0.473476742105709,-0.481660598973505,-0.489411521569614,-0.496733200809558,-0.503629123207261,-0.510102572535293,-0.516156631388572,-0.521794182652267,-0.527017910874598,-0.531830303545195,-0.536233652279615,-0.540230053910590,-0.543821411486514,-0.547009435177662,-0.549795643090554,-0.552181361990862,-0.554167727935206,-0.555755686812130,-0.556945994792528,-0.557739218689725,-0.558135736229386,-0.558135736229386,-0.557739218689725,-0.556945994792529,-0.555755686812130,-0.554167727935206,-0.552181361990863,-0.549795643090555,-0.547009435177663,-0.543821411486515,-0.540230053910591,-0.536233652279616,-0.531830303545196,-0.527017910874599,-0.521794182652269,-0.516156631388574,-0.510102572535295,-0.503629123207262,-0.496733200809560,-0.489411521569616,-0.481660598973506,-0.473476742105710,-0.464856053891528,-0.455794429241335,-0.446287553095772,-0.436330898370962,-0.425919723802749,-0.415049071688958,-0.403713765528583,-0.391908407556786,-0.379627376174529,-0.366864823271632,-0.353614671441948,-0.339870611089370,-0.325626097423252,-0.310874347341850,-0.295608336202266,-0.279820794475388,-0.263504204284203,-0.246650795823856,-0.229252543661749,-0.211301162915899,-0.192788105309761,-0.173704555101617,-0.154041424886606,-0.133789351269388,-0.112938690405384,-9.147951340846650E-002,-6.940160162292419E-002,-4.669444175743009E-002,-2.334722087871499E-002,1.110223024625157E-016};
double uec50[] = {-8.208301895966985E-002,-0.164166037919340,-0.241169797700189,-0.313405980187046,-0.381166969928070,-0.444727037596023,-0.504343450131478,-0.560257512061375,-0.612695542207810,-0.661869789740425,-0.707979293280184,-0.751210686531892,-0.791738953706328,-0.829728137789676,-0.865332004527035,-0.898694664807579,-0.929951157970540,-0.959227998393010,-0.986643687571945,-1.01230919377307,-1.03632840118814,-1.05879853041862,-1.07981053198756,-1.09944945447276,-1.11779478875094,-1.13492078974654,-1.15089677698741,-1.16578741518379,-1.17965297596649,-1.19254958184344,-1.20452943336223,-1.21564102039805,-1.22592931842225,-1.23543597054588,-1.24419945607514,-1.25225524626100,-1.25963594787324,-1.26637143518030,-1.27248897086891,-1.27801331639302,-1.28296683219883,-1.28736956823124,-1.29123934508850,-1.29459182615311,-1.29744058099130,-1.29979714027741,-1.30167104246568,-1.30306987239832,-1.30399929200601,-1.30446306322524,-1.30446306322524,-1.30399929200601,-1.30306987239832,-1.30167104246568,-1.29979714027741,-1.29744058099130,-1.29459182615311,-1.29123934508850,-1.28736956823124,-1.28296683219883,-1.27801331639302,-1.27248897086891,-1.26637143518030,-1.25963594787324,-1.25225524626100,-1.24419945607514,-1.23543597054588,-1.22592931842225,-1.21564102039805,-1.20452943336223,-1.19254958184344,-1.17965297596649,-1.16578741518379,-1.15089677698741,-1.13492078974654,-1.11779478875094,-1.09944945447276,-1.07981053198756,-1.05879853041862,-1.03632840118815,-1.01230919377307,-0.986643687571945,-0.959227998393011,-0.929951157970540,-0.898694664807579,-0.865332004527035,-0.829728137789676,-0.791738953706328,-0.751210686531892,-0.707979293280184,-0.661869789740425,-0.612695542207810,-0.560257512061375,-0.504343450131478,-0.444727037596023,-0.381166969928070,-0.313405980187046,-0.241169797700189,-0.164166037919340,-8.208301895966985E-002,0.000000000000000E+000};
double ue50[] = {-8.672451393975933E-002,-0.173449027879519,-0.255014555071067,-0.331690269302005,-0.403734073743575,-0.471392856664228,-0.534902759206326,-0.594489453198858,-0.650368427117788,-0.702745278439792,-0.751816010764684,-0.797767334206342,-0.840776967671321,-0.881013941758519,-0.918638901122024,-0.953804405242610,-0.986655226651270,-1.01732864574076,-1.04595474138815,-1.07265667669301,-1.09755097921235,-1.12074781514451,-1.14235125698024,-1.16245954420002,-1.18116533665285,-1.19855596030278,-1.21471364507592,-1.22971575458245,-1.24363500752555,-1.25653969064202,-1.26849386304807,-1.27955755188815,-1.28978693920504,-1.29923453996579,-1.30794937119035,-1.31597711213803,-1.32336025551172,-1.33013824963996,-1.33634763159405,-1.34202215118969,-1.34719288581167,-1.35188834598455,-1.35613457159257,-1.35995521862796,-1.36337163631826,-1.36640293444958,-1.36906604066390,-1.37137574746459,-1.37334474861400,-1.37498366455043,-1.37630105638856,-1.37730342799635,-1.37799521556213,-1.37837876397762,-1.37845428926428,-1.37821982616117,-1.37767115987155,-1.37680174083036,-1.37560258120546,-1.37406213167921,-1.37216613687255,-1.36989746756873,-1.36723592766602,-1.36415803353575,-1.36063676318018,-1.35664127227199,-1.35213657380837,-1.34708317772504,-1.34143668638366,-1.33514734136471,-1.32815951646214,-1.32041115117803,-1.31183311834915,-1.30234851879380,-1.29187189503734,-1.28030835524896,-1.26755259748767,-1.25348782320068,-1.23798452762635,-1.22089915331193,-1.20207259134344,-1.18132851308244,-1.15847151318728,-1.13328504244075,-1.10552910638068,-1.07493770290407,-1.04121596885106,-1.00403700203116,-0.963038321184953,-0.917817921926802,-0.867929881729632,-0.812879461426181,-0.752117644436238,-0.685035047904622,-0.610955132054338,-0.529126625217764,-0.438715072086916,-0.338793401586697,-0.228331398271346,-0.106183947102836,1.596350406567409E-002};


// todo:
/* обработчик ошибок */
void erro(char *op, ...) {
	va_list f;
	va_start(f, op);

	int i = va_arg(f, int);
	switch (i)
	{
		case 1:
		case 2:
		case 3:
		case 4:
			printf("ОШИБКА ВВОДА: ");
			if (1 < i && i < 4) printf("КООРДИНАТЫ>> ");
			printf("%s\n\tдля просмотра справки вызовите программу с ключом -help.\n", op);
			break;
		default:
			printf("%s\n", op);
	}

	va_end(f);
	exit(i);
}

/* модуль */
double m(double i) {
        return i > 0 ? i : -i;
}

/* меняет местами два double */
void swapch(double *a, double *b) {
	double c = *a; *a = *b; *b = c;
}

/* магнитное поле H(x,y) */
double pole(double x, double y) {
	return he;
}

/* температура T(x,y) */
double temp(double x, double y) {
	return T;
}

/* глубина проникновения λ(T) */
double lamb(double t) {
	return L;
}

/* длина когерентности ξ(T) */
double ksii(double t) {
	return K;
}

/* энергия взаимодействия с магнитным полем E1(H,λ,x,y) */
double e1(double h, double l, double x, double y) {
//	return ue60[(int)(x / X * 100)] * h;
	return E1X;
}
double e1_old(double h, double l, double x, double y) {
	return E1X;
}

/* собственая энергия вихря E2(λ,ξ) */
double e2(double l, double xi) {
	return E2;
}

/* энергия взаимодействия вихря с другим вихрем E3(r,λ) */
double e3(double r, double l) {
	return E3;
}

/* энергия взаимодействия вихря с примесью E4(r,ξ,U) */
double e4(double r, double xi, double u) {
	return E4;
}

/* определяет минимальное расстояние между двумя точками с учётом стенок и границ системы */
double rrr(double x1, double y1, double x2, double y2) {
	double xi, yi, x, y;

	xi = m(x1 - x2); yi = m(y1 - y2);
#if XG == 1
	x = xi;
#else
	x = (xi < X - xi) ? xi : X - xi;
#endif
#if YG == 1
	y = yi;
#else
	y = (yi < Y - yi) ? yi : Y - yi;
#endif

	return pow(x * x + y * y, 0.5);
}

/* определяет минимальное расстояние между двумя точками без учёта стенок и границ системы */
double rrb(double x1, double y1, double x2, double y2) {
	double x = m(x1 - x2), y = m(y1 - y2);

	return pow(x * x + y * y, 0.5);
}

/* проверяет, есть ли в vortex *a вихрь рядом с координатами (x,y) (vortex *a имеет размер n) */
char check(struct vortex *a, int n, double x, double y) {
	for (int i = 0; i < n; i++)
		if (rrr(a[i].x,a[i].y,x,y) <= DR) return 1;

	return 0;
}

/* меняет местами два вихря */
void swapvi(struct vortex *a, int i, int j) {
	double s;

	s = a[i].x; a[i].x = a[j].x; a[j].x = s;
	s = a[i].y; a[i].y = a[j].y; a[j].y = s;
	s = a[i].zn; a[i].zn = a[j].zn; a[j].zn = s;
	s = a[i].t; a[i].t = a[j].t; a[j].t = s;
	s = a[i].h; a[i].h = a[j].h; a[j].h = s;
	s = a[i].l; a[i].l = a[j].l; a[j].l = s;
	s = a[i].xi; a[i].xi = a[j].xi; a[j].xi = s;
	s = a[i].e; a[i].e = a[j].e; a[j].e = s;
}

/* копирует struct vortex *b в память и возвращает ссылку на копию (struct vortex *b имеет размер n) */
struct vortex *cpo(struct vortex *b, int n) {
	struct vortex *a;

	a = malloc(n * sizeof(struct vortex));
	for (int i = 0; i < i; i++)
	{
		a[i].x = b[i].x;
		a[i].y = b[i].y;
		a[i].zn = b[i].zn;
		a[i].t = b[i].t;
		a[i].h = b[i].h;
		a[i].l = b[i].l;
		a[i].xi = a[i].xi;
		a[i].e = b[i].e;
	}

	return a;
}


/* --- */


/* считает энергию от магнитного поля всей vortex *a (vortex *a имеет размер n) */
double tote1(struct vortex *a, int n) {
	double v = 0, f = 0, s, t;

	for (int i = 0; i < n; i++)
	{
		s = ((a[i].zn == 'o') ? 1 : -1) * e1(a[i].h,a[i].l,a[i].x,a[i].y) - f;
		t = v + s;
		f = (t - v) - s;
		v = t;
	}

	return v;
}

/* считает внутреннию энергию всех вихрей всей vortex *a (vortex *a имеет размер n) */
double tote2(struct vortex *a, int n) {
	double v = 0, f = 0, s, t;

	for (int i = 0; i < n; i++)
	{
		s = e2(a[i].l,a[i].xi) - f;
		t = v + s;
		f = (t - v) - s;
		v = t;
	}

	return v;
}

/* считает энергию взаимодействий типа вихрь-вихрь последней в vortex *a частицы (vortex *a имеет размер n) */
double eone3(struct vortex *a, int n) {
	double v = 0, f = 0, s, t, r;

	for (int i = 0; i < n - 1; i++)
	{
		r = rrr(a[n - 1].x,a[n - 1].y,a[i].x,a[i].y);
		if (a[i].zn == a[n - 1].zn)
			s = e3(r,a[n - 1].l) + e3(r,a[i].l) - f;
		else
			s = -e3(r,a[n - 1].l) - e3(r,a[i].l) - f;
		t = v + s;
		f = (t - v) - s;
		v = t;

#if XG == 1
		// todo:
		// if (a[i].x < X / 2)

		r = rrb(a[n - 1].x,a[n - 1].y,-a[i].x,a[i].y);
		if (a[i].zn == a[n - 1].zn)
			s = -(e3(r,a[n - 1].l) + e3(r,a[i].l)) - f;
//			s = -(e3(r,a[n - 1].l) + e3(r,a[i].l)) / 2 - f;
		else
			s = e3(r,a[n - 1].l) + e3(r,a[i].l) - f;
//			s = (e3(r,a[n - 1].l) + e3(r,a[i].l)) / 2 - f;
		t = v + s;
		f = (t - v) - s;
		v = t;

		r = rrb(a[n - 1].x,a[n - 1].y,2 * X - a[i].x,a[i].y);
		if (a[i].zn == a[n - 1].zn)
			s = -(e3(r,a[n - 1].l) + e3(r,a[i].l)) - f;
//			s = -(e3(r,a[n - 1].l) + e3(r,a[i].l)) / 2 - f;
		else
			s = e3(r,a[n - 1].l) + e3(r,a[i].l) - f;
//			s = (e3(r,a[n - 1].l) + e3(r,a[i].l)) / 2 - f;
		t = v + s;
		f = (t - v) - s;
		v = t;
#endif
#if YG == 1
		// todo:
		//if (a[i].y < Y / 2)

		r = rrb(a[n - 1].x,a[n - 1].y,a[i].x,-a[i].y);
		if (a[i].zn == a[n - 1].zn)
			s = -(e3(r,a[n - 1].l) + e3(r,a[i].l)) - f;
//			s = -(e3(r,a[n - 1].l) + e3(r,a[i].l)) / 2 - f;
		else
			s = e3(r,a[n - 1].l) + e3(r,a[i].l) - f;
//			s = (e3(r,a[n - 1].l) + e3(r,a[i].l)) / 2 - f;
		t = v + s;
		f = (t - v) - s;
		v = t;

		r = rrb(a[n - 1].x,a[n - 1].y,a[i].x,2 * Y - a[i].y);
		if (a[i].zn == a[n - 1].zn)
			s = -(e3(r,a[n - 1].l) + e3(r,a[i].l)) - f;
//			s = -(e3(r,a[n - 1].l) + e3(r,a[i].l)) / 2 - f;
		else
			s = e3(r,a[n - 1].l) + e3(r,a[i].l) - f;
//			s = (e3(r,a[n - 1].l) + e3(r,a[i].l)) / 2 - f;
		t = v + s;
		f = (t - v) - s;
		v = t;
#endif
	}
#if XG == 1
	// todo:
	// if (a[i].x < X / 2)

	r = rrb(a[n - 1].x,a[n - 1].y,-a[n - 1].x,a[n - 1].y);
	s = -e3(r,a[n - 1].l) - f;
	t = v + s;
	f = (t - v) - s;
	v = t;

	r = rrb(a[n - 1].x,a[n - 1].y,2 * X - a[n - 1].x,a[n - 1].y);
	s = -e3(r,a[n - 1].l) - f;
	t = v + s;
	f = (t - v) - s;
	v = t;
#endif
#if YG == 1
	// todo:
	//if (a[i].y < Y / 2)

	r = rrb(a[n - 1].x,a[n - 1].y,a[n - 1].x,-a[n - 1].y);
	s = -e3(r,a[n - 1].l) - f;
	t = v + s;
	f = (t - v) - s;
	v = t;

	r = rrb(a[n - 1].x,a[n - 1].y,a[n - 1].x,2 * Y - a[n - 1].y);
	s = -e3(r,a[n - 1].l) - f;
	t = v + s;
	f = (t - v) - s;
	v = t;
#endif

	return v;
}

// todo: криво считает отражения 
/* считает всю энергию взаимодействий типа вихрь-вихрь в vortex *a (vortex *a имеет размер n) */
double tote3(struct vortex *a, int n) {
	double r, v = 0, f = 0, s, t;
	int i, j;

	for (j = 0; j < n; j++)
	{
		for (i = 0; i < j; i++)
		{
			r = rrr(a[j].x,a[j].y,a[i].x,a[i].y);
			if (a[i].zn == a[j].zn)
				s = e3(r,a[j].l) + e3(r,a[i].l) - f;
			else
				s = -e3(r,a[j].l) - e3(r,a[i].l) - f;
			t = v + s;
			f = (t - v) - s;
			v = t;

#if XG == 1
			// todo:
			// if (a[i].x < X / 2)

			r = rrb(a[j].x,a[j].y,-a[i].x,a[i].y);
			if (a[j].zn == a[i].zn)
				s = -(e3(r,a[j].l) + e3(r,a[i].l)) - f;
//				s = -(e3(r,a[j].l) + e3(r,a[i].l)) / 2 - f;
			else
				s = e3(r,a[j].l) + e3(r,a[i].l) - f;
//				s = (e3(r,a[j].l) + e3(r,a[i].l)) / 2 - f;
			t = v + s;
			f = (t - v) - s;
			v = t;

			r = rrb(a[j].x,a[j].y,2 * X - a[i].x,a[i].y);
			if (a[i].zn == a[j].zn)
				s = -(e3(r,a[j].l) + e3(r,a[i].l)) - f;
//				s = -(e3(r,a[j].l) + e3(r,a[i].l)) / 2 - f;
			else
				s = e3(r,a[j].l) + e3(r,a[i].l) - f;
//				s = (e3(r,a[j].l) + e3(r,a[i].l)) / 2 - f;
			t = v + s;
			f = (t - v) - s;
			v = t;
#endif
#if YG == 1
			// todo:
			//if (a[i].y < Y / 2)
			r = rrb(a[j].x,a[j].y,a[i].x,-a[i].y);
			if (a[j].zn == a[i].zn)
				s = -(e3(r,a[j].l) + e3(r,a[i].l)) - f;
//				s = -(e3(r,a[j].l) + e3(r,a[i].l)) / 2 - f;
			else
				s = e3(r,a[j].l) + e3(r,a[i].l) - f;
//				s = (e3(r,a[j].l) + e3(r,a[i].l)) / 2 - f;
			t = v + s;
			f = (t - v) - s;
			v = t;

			r = rrb(a[j].x,a[j].y,a[i].x,2 * Y - a[i].y);
			if (a[i].zn == a[j].zn)
				s = -(e3(r,a[j].l) + e3(r,a[i].l)) - f;
//				s = -(e3(r,a[j].l) + e3(r,a[i].l)) / 2 - f;
			else
				s = e3(r,a[j].l) + e3(r,a[i].l) - f;
//				s = (e3(r,a[j].l) + e3(r,a[i].l)) / 2 - f;
			t = v + s;
			f = (t - v) - s;
			v = t;
#endif
		}
#if XG == 1
		// todo:
		// if (a[i].x < X / 2)

		r = rrb(a[j].x,a[j].y,-a[j].x,a[j].y);
		s = -e3(r,a[j].l) - f;
		t = v + s;
		f = (t - v) - s;
		v = t;

		r = rrb(a[j].x,a[j].y,2 * X - a[j].x,a[j].y);
		s = -e3(r,a[j].l) - f;
		t = v + s;
		f = (t - v) - s;
		v = t;
#endif
#if YG == 1
		// todo:
		//if (a[i].y < Y / 2)

		r = rrb(a[j].x,a[j].y,a[j].x,-a[j].y);
		s = -e3(r,a[j].l) - f;
		t = v + s;
		f = (t - v) - s;
		v = t;

		r = rrb(a[j].x,a[j].y,a[j].x,2 * Y - a[j].y);
		s = -e3(r,a[j].l) - f;
		t = v + s;
		f = (t - v) - s;
		v = t;
#endif
	}

	return v;
}

/* считает энергию взаимодействий типа вихрь-примесь n-го вихря в vortex *a */
double eone4(struct vortex *a, int n) {
	int i, ii;
	double r, v;

	for (v = e4(rrr(a[n].x,a[n].y,pr[0].x,pr[0].y),a[n].xi,pr[0].u), ii = 0, i = 1; i < NP; i++)
	{
		r = e4(rrr(a[n].x,a[n].y,pr[i].x,pr[i].y),a[n].xi,pr[i].u);
		if (r < v)
		{
			v = r;
			ii = i;
		}
	}

	return v;
}
/* считает всю энергию взаимодействий типа вихрь-примесь в vortex *a (vortex *a имеет размер n) */
double tote4(struct vortex *a, int n) {
	int i, j, ii;
	double r, vv, v = 0, f = 0, s, t;

	for (j = 0; j < n; j++)
	{
		for (vv = e4(rrr(a[j].x,a[j].y,pr[0].x,pr[0].y),a[j].xi,pr[0].u), ii = 0, i = 1; i < NP; i++)
		{
			r = e4(rrr(a[j].x,a[j].y,pr[i].x,pr[i].y),a[j].xi,pr[i].u);
			if (r < vv)
			{
				vv = r;
				ii = i;
			}
		}
		s = vv - f;
		t = v + s;
		f = (t - v) - s;
		v = t;
	}

	return v;
}

/* считает все стационарные энергии, записаные заранее в vortex *a (vortex *a имеет размер n) */
double tote124(struct vortex *a, int n) {
	double r, v = 0, f = 0, s, t;
	int i, j;

	for (i = 0; i < n; i++)
	{
		s = a[i].e - f;
		t = v + s;
		f = (t - v) - s;
		v = t;
	}

	return v;
}



/* --- */
// параметр гексагональности
FILE *out2;

/* возвращает 1, если координата находится близко к границе */
char grani(double x, double y, double u) {
// определяет характер границ
// 0	-- все границы периодеческие
// 1	-- периодичны границы по Y
// 2	-- периодичны границы по X
// 3	-- нет периодичных границ // fail: не работает так как надо

#if !(XG == 1)
	if (x <= u || (X - x) <= u) return 1;
#endif
#if !(YG == 1)
	if (y <= u || (Y - y) <= u) return 1;
#endif

	return 0;
}

/* считает угол между тремя точками по координатам (координаты первой точки -- центр угла) */
double ugol(double xc, double yc, double x1, double y1, double x2, double y2) {
//	return atan(((y2 - yc) * (x1 - xc) - (y1 - yc) * (x2 - xc)) / ((x2 - xc) * (x1 - xc) + (y2 - xc) * (y1 - xc))) * 180 / M_PI;

	double v1[] = {x1 - xc, y1 - yc};
	double v2[] = {x2 - xc, y2 - yc};

	double vv1 = pow(v1[0] * v1[0] + v1[1] * v1[1], 0.5);
	double vv2 = pow(v2[0] * v2[0] + v2[1] * v2[1], 0.5);

	double nv1[] = {v1[0] / vv1, v1[1] / vv1};
	double nv2[] = {v2[0] / vv2, v2[1] / vv2};


	return acos(nv1[0] * nv2[0] + nv1[1] * nv2[1]) * 180 / M_PI;
}

/* считает параметр гексагональноти в vortex a, который имеет размет n без учёта вихрей, отстающих < u от границ */
double gex(struct vortex *a, int n, double u) {
	double r, r6[6], *g, *razb;
	int i = 0, j = 0, jj = 0, n6[6], ph6[6], ng = 0;


	g = malloc(sizeof(double));
	for (i = 0; i < n; i++)
	{
		if (grani(a[i].x,a[i].y,u)) continue;

		// поиск ближайших вихрей к i-ому вихрю
		r6[0] = r6[1] = r6[2] = r6[3] = r6[4] = r6[5] = X + Y;
		n6[0] = n6[1] = n6[2] = n6[3] = n6[4] = n6[5] = -1;
		for (j = 0; j < n; j++)
		{
			if (i == j) continue;

			r = rrr(a[j].x,a[j].y,a[i].x,a[i].y);

			if (r < r6[5])
			{
				r6[5] = r; n6[5] = j;
			}
			if (r < r6[4])
			{
				r6[5] = r6[4]; n6[5] = n6[4];
				r6[4] = r; n6[4] = j;
			}
			if (r < r6[3])
			{
				r6[4] = r6[3]; n6[4] = n6[3];
				r6[3] = r; n6[3] = j;
			}
			if (r < r6[2])
			{
				r6[3] = r6[2]; n6[3] = n6[2];
				r6[2] = r; n6[2] = j;
			}
			if (r < r6[1])
			{
				r6[2] = r6[1]; n6[2] = n6[1];
				r6[1] = r; n6[1] = j;
			}
			if (r < r6[0])
			{
				r6[1] = r6[0]; n6[1] = n6[0];
				r6[0] = r; n6[0] = j;
			}
		}

		// поиск углов
		r6[0] = r6[1] = r6[2] = r6[3] = r6[4] = r6[5] = 400;
		ph6[0] = ph6[1] = ph6[2] = ph6[3] = ph6[4] = ph6[5] = -1;
		for (j = 0; j < 6; j++)
		{
			for (jj = 0; jj < 6; jj++)
			{
				if (j == jj || ph6[jj] == j) continue;

				r = ugol(a[i].x,a[i].y,a[n6[j]].x,a[n6[j]].y,a[n6[jj]].x,a[n6[jj]].y);

				if (r < r6[j])
				{
					r6[j] = r;
					ph6[j] = jj;
				}
			}
		}

		g = realloc(g, (ng + 1) * sizeof(double));
		g[ng] = 0;
		// суммирование углов
		for (j = 0; j < 6; j++)
			g[ng] = g[ng] + (cos(6 * r6[j] * M_PI / 180) + 1) / 2;
		ng++;

		//printf("%d :%8d|%8d|%8d|%8d|%8d|%8d -- %.8f\n", i, n6[0], n6[1], n6[2], n6[3], n6[4], n6[5], g[ng - 1]);
		//printf(">  %8.4f|%8.4f|%8.4f|%8.4f|%8.4f|%8.4f\n", r6[0], r6[1], r6[2], r6[3], r6[4], r6[5]);
		//fflush(stdout);

//		fprintf(out2, "%.8f,%.8f,%.8f,%.8f\n", g[ng - 1] / 6, a[i].t, a[i].x, a[i].y);
	}

	double su = 0;
	for (i = 0; i < ng; i++)
		su = su + g[i];

	return su / (6 * ng);
}


/* --- */


/* программа показывает статус при нажатии 's' */
void show() {
	system("clear");
	printf("шагов: %d / %llu\nвихрей: %d\ntotal: %.16f\n+++++: %.16f\nH: %.1f\n", nm, k, nn[nm], tote1(v[nm],nn[nm]) + tote2(v[nm],nn[nm]) + tote3(v[nm],nn[nm]) + tote4(v[nm],nn[nm]), e[nm], he);
	fflush(stdout);
}

/* создаёт случайный новый вихрь в vortex *a (vortex *a имеет размеры n) */
struct vortex *new(struct vortex *a, int *n) {
	char zn = rand() % 2 ? 'o' : 'x';
	double x, y;

#if XG == 1
	x = (double)rand() / RAND_MAX * (BRN - DRN) + (rand() % 2 ? DRN : X - L0);
#else
	x = (double)rand() / RAND_MAX * X;
#endif
#if YG == 1
	y = (double)rand() / RAND_MAX * (BRN - DRN) + (rand() % 2 ? DRN : Y - L0);
#else
	y = (double)rand() / RAND_MAX * Y;
#endif

	if (check(a,*n,x,y)) return 0;

	a = realloc(a, (*n + 1) * sizeof(struct vortex));

	a[*n].x = x;
	a[*n].y = y;
	a[*n].zn = zn;
//	a[*n].zn = 'o';
	a[*n].t = temp(x,y);
	a[*n].h = pole(x,y);
	a[*n].l = lamb(a[*n].t);
	a[*n].xi = ksii(a[*n].t);
	a[*n].e = ((a[*n].zn == 'o') ? 1 : -1) * e1(a[*n].h,a[*n].l,a[*n].x,a[*n].y) + e2(a[*n].l,a[*n].xi) + eone4(a,*n);

	*n = *n + 1;

	return a;
}


/* сохраняет всю информацию на диск в файл с названием *ss */
void save(char *ss) {
	int i, j;
	FILE *out;

	out = fopen(ss, "w");
	fprintf(out, "* : %.16f\n",  e[0]);
	for (i = 0; i < nn[0]; i++)
		fprintf(out, "%c(%.8f;%.8f) ", v[0][i].zn, v[0][i].x, v[0][i].y);
	fprintf(out, "\n");
	for (i = 0; i < nm; i++)
	{
		fprintf(out, "%lld : %.16f\n", (unsigned long long)i, e[i]);
		for (j = 0; j < nn[i]; j++)
			fprintf(out, "%c(%.8f;%.8f) ", v[i][j].zn, v[i][j].x, v[i][j].y);
		fprintf(out, "\n");
	}
	fflush(out);
	fclose(out);
}




char qqq = 0;
double ff = 0, fs = 0;
double tempcikl = 0;
FILE *geex;

char q1 = 1, q2 = 0, q3 = 0;

/* условие остановки */
char stopr(double ee) {
	int i, j;
	double f, s, g;
	FILE *gist;


	s = ee - ff;
	g = e[nm] + s;
	f = (g - e[nm]) - s;
	e[nm] = g;

#if D < 0
	if (k > d + dk)
	{
		dk = k;
		d = (nn[nm] < DM) ? DM : nn[nm];
#else
	if (k > D + dk)
	{
#endif

#if N > 0
//		if (tempnm < 20000)
//		{
//			tempnm++;
//			return 0;
//		}

		tempcikl++;
		if (tempcikl < 20) return 0;
		else tempcikl = 0;
#endif
//		fprintf(geex, "%.8f;", gex(v[nm],nn[nm],L0));

		/*
		FILE *new;
		new = fopen("acor.txt", "a+t");

		fprintf(new, "%lld : %.16f\n", (unsigned long long)nm, e[nm]);
		for (j = 0; j < nn[nm]; j++)
			fprintf(new, "%c(%.8f;%.8f) ", v[nm][j].zn, v[nm][j].x, v[nm][j].y);
		fprintf(new, "\n");
		fflush(new);
		fclose(new);
		*/

		nm++;
		v = realloc(v, (nm + 1) * sizeof(struct vortex *));
		v[nm] = malloc(nn[nm - 1] * sizeof(struct vortex));
		nn = realloc(nn, (nm + 1) * sizeof(int));
		nn[nm] = nn[nm - 1];
		for (i = 0; i < nn[nm]; i++)
		{
			v[nm][i].x = v[nm - 1][i].x;
			v[nm][i].y = v[nm - 1][i].y;
			v[nm][i].zn = v[nm - 1][i].zn;
			v[nm][i].t = v[nm - 1][i].t;
			v[nm][i].h = v[nm - 1][i].h;
			v[nm][i].l = v[nm - 1][i].l;
			v[nm][i].xi = v[nm - 1][i].xi;
			v[nm][i].e = v[nm - 1][i].e;
		}
		e = realloc(e, (nm + 1) * sizeof(double));
		e[nm] = e[nm - 1];


		// условия выхода, если задано минимальное количество физических шагов
		if (nm > N)
		{
			char ss[512];
			he = 0;
			if (nm > 100000)
			{
				qqq = 1;
				snprintf(ss, 512, "relax/coordinat h1200T160d1.8.txt");
				save(ss);
			}
			gist = fopen("relax/h1200T160d1.8.txt", "a+t");
			fprintf(gist, "%d %d %.16f %.16f %.16f %.16f\n", nm, nn[nm], tote1(v[nm],nn[nm]) + tote2(v[nm],nn[nm]) + tote3(v[nm],nn[nm]) + tote4(v[nm],nn[nm]), tote1(v[nm],nn[nm]), tote2(v[nm],nn[nm]), tote3(v[nm],nn[nm]), tote4(v[nm],nn[nm]));
			fflush(gist);
			fclose(gist);

			return 0;


			gist = fopen("h1200T20/d1.0T1.txt", "a+t");
			for (j = i = 0; i < nn[nm]; i++)
				if (v[nm][i].zn == 'o') j++;
			fprintf(gist, "%.1f %.16f %d %d %d %.16f %.16f %.16f %.16f %.16f\n", he, he - (j - nn[nm] + j) * EF / (X * Y), nn[nm], j, nn[nm] - j, tote1(v[nm],nn[nm]), tote2(v[nm],nn[nm]), tote3(v[nm],nn[nm]), tote4(v[nm],nn[nm]), tote1(v[nm],nn[nm]) + tote2(v[nm],nn[nm]) + tote3(v[nm],nn[nm]) + tote4(v[nm],nn[nm]));

			fflush(gist);
			fclose(gist);

			snprintf(ss, 512, "h1200T20/coordinat d1.0T1.txt");
			save(ss);

			qqq = 1;
			return 0;


			if (q3 && he >= HE)
				qqq = 1; // заканчиваем работу

			show();

			if (-HE < he && he < HE)
			{
VO:				char ss[512];

				gist = fopen("T160d18e/gistogram.txt", "a+t");
				for (j = i = 0; i < nn[nm]; i++)
					if (v[nm][i].zn == 'o') j++;
				fprintf(gist, "%.1f %.16f %d %d %d %.16f %.16f %.16f %.16f %.16f\n", he, he - (j - nn[nm] + j) * EF / (X * Y), nn[nm], j, nn[nm] - j, tote1(v[nm],nn[nm]), tote2(v[nm],nn[nm]), tote3(v[nm],nn[nm]), tote4(v[nm],nn[nm]), tote1(v[nm],nn[nm]) + tote2(v[nm],nn[nm]) + tote3(v[nm],nn[nm]) + tote4(v[nm],nn[nm]));

				fflush(gist);
				fclose(gist);

				snprintf(ss, 512, "T160d18e/coordinat %.1fH %d %d.txt", he, q1, q2);
				save(ss);


				if (q1)
					he = he + HI;
				else
					he = he - HI;


				nn[0] = nn[1] = nn[nm];
				nn = realloc(nn, 2 * sizeof(int));
				v[0] = realloc(v[0], nn[0] * sizeof(struct vortex));
				v[1] = realloc(v[1], nn[1] * sizeof(struct vortex));
				for (i = 0; i < nn[0]; i++)
				{
					v[0][i].x = v[1][i].x = v[nm][i].x;
					v[0][i].y = v[1][i].y = v[nm][i].y;
					v[0][i].zn = v[1][i].zn = v[nm][i].zn;
					v[0][i].t = v[1][i].t = temp(v[0][i].x,v[0][i].y);
					v[0][i].h = v[1][i].h = pole(v[0][i].x,v[0][i].y);
					v[0][i].l = v[1][i].l = lamb(v[0][i].t);
					v[0][i].xi = v[1][i].xi = ksii(v[0][i].t);
					v[0][i].e = v[1][i].e = ((v[0][i].zn == 'o') ? 1 : -1) * e1(v[0][i].h,v[0][i].l,v[0][i].x,v[0][i].y) + e2(v[0][i].l,v[0][i].xi) + eone4(v[0],i);
				}
				v = realloc(v, 2 * sizeof(struct vortex *));

				e = realloc(e, 2 * sizeof(double));
				e[0] = e[1] = tote1(v[0],nn[0]) + tote2(v[0],nn[0]) + tote3(v[0],nn[0]) + tote4(v[0],nn[0]);

				nm = 1;
				k = 0;
				d = 0;
				dk = 0;
				tempcikl = 0;
				ff = 0;

				return 0;
			}
			if (q1)
			{
				q1 = 0;
				q2 = 1;
				goto VO;
			}
			if (q2)
			{
				q1 = 1;
				q3 = 1;
				goto VO;
			}
		}
	}



			/*
			if (q3 && he >= HE)
				qqq = 1; // заканчиваем работу

			show();

			if (-HE < he && he < HE)
			{
VO:				char ss[512];

				gist = fopen("T60d18/gistogram.txt", "a+t");
				for (j = i = 0; i < nn[nm]; i++)
					if (v[nm][i].zn == 'o') j++;
				fprintf(gist, "%.1f %.16f %d %d %d\n", he, he - (j - nn[nm] + j) * EF / (X * Y), nn[nm], j, nn[nm] - j);

				fflush(gist);
				fclose(gist);

				snprintf(ss, 512, "T60d18/coordinat %.1fH %d %d.txt", he, q1, q2);
				save(ss);


				if (q1)
					he = he + HI;
				else
					he = he - HI;


				nn[0] = nn[1] = nn[nm];
				nn = realloc(nn, 2 * sizeof(int));
				v[0] = realloc(v[0], nn[0] * sizeof(struct vortex));
				v[1] = realloc(v[1], nn[1] * sizeof(struct vortex));
				for (i = 0; i < nn[0]; i++)
				{
					v[0][i].x = v[1][i].x = v[nm][i].x;
					v[0][i].y = v[1][i].y = v[nm][i].y;
					v[0][i].zn = v[1][i].zn = v[nm][i].zn;
					v[0][i].t = v[1][i].t = temp(v[0][i].x,v[0][i].y);
					v[0][i].h = v[1][i].h = pole(v[0][i].x,v[0][i].y);
					v[0][i].l = v[1][i].l = lamb(v[0][i].t);
					v[0][i].xi = v[1][i].xi = ksii(v[0][i].t);
					v[0][i].e = v[1][i].e = ((v[0][i].zn == 'o') ? 1 : -1) * e1(v[0][i].h,v[0][i].l,v[0][i].x,v[0][i].y) + e2(v[0][i].l,v[0][i].xi) + eone4(v[0],i);
				}
				v = realloc(v, 2 * sizeof(struct vortex *));

				e = realloc(e, 2 * sizeof(double));
				e[0] = e[1] = tote1(v[0],nn[0]) + tote2(v[0],nn[0]) + tote3(v[0],nn[0]) + tote4(v[0],nn[0]);

				nm = 1;
				k = 0;
				d = 0;
				dk = 0;
				tempcikl = 0;
				ff = 0;

				return 0;
			}
			if (q1)
			{
				q1 = 0;
				q2 = 1;
				goto VO;
			}
			if (q2)
			{
				q1 = 1;
				q3 = 1;
				goto VO;
			}
		}
	}
			*/

	return 0;
}


// скорость
FILE *fsp;

/* ветка основного алгоритма */
void *three() {
	int i;
	double g, x, y, t, h, l, xi;


	e0 = 0;
	k++;

	i = rand() % RND;
	if (i == 1 || nn[nm] != 0)
	{
		switch (i)
		{
			case 0: // удаление
//				break;
				i = rand() % nn[nm];

#if XG == 1
				if ((v[nm][i].x <= X - L0) && (v[nm][i].x >= L0)) break;
#endif
#if YG == 1
				if ((v[nm][i].y <= Y - L0) && (v[nm][i].y >= L0)) break;
#endif

				swapvi(v[nm],i,nn[nm] - 1);

				e0 = -(eone3(v[nm],nn[nm]) + v[nm][nn[nm] - 1].e);

				g = nn[nm] / TA * (double)nn[nm] * exp(-e0 / v[nm][nn[nm] - 1].t);
				if (g < 1)
				{
					if ((double)rand() / RAND_MAX <= g)
					{
						v[nm] = realloc(v[nm], nn[nm] * sizeof(struct vortex));
						nn[nm]--;
					}
					else e0 = 0;
				}
				else
				{
					v[nm] = realloc(v[nm], nn[nm] * sizeof(struct vortex));
					nn[nm]--;
				}
				break;
			case 1: // создание
//				break;
				struct vortex *a;

//				v[nm] = new(v[nm],&nn[nm]);
				a = new(v[nm],&nn[nm]);
				if (!a) break;
				v[nm] = a;

				e0 = eone3(v[nm],nn[nm]) + v[nm][nn[nm] - 1].e;

				g = (double)TA / (nn[nm] + 1) * exp(-e0 / v[nm][nn[nm] - 1].t);
				if (g < 1)
				{
					if ((double)rand() / RAND_MAX > g)
					{
						v[nm] = realloc(v[nm], nn[nm] * sizeof(struct vortex));
						nn[nm]--;
						e0 = 0;
					}
				}
				break;
			case 2: // анигиляция
//				break;
				int j, xx, yy;

				for (i = xx = yy = 0; i < nn[nm]; i++)
					if (v[nm][i].zn == 'o') yy++;
					else xx++;

				if (xx && yy)
				{
					i = rand() % xx;
					j = rand() % yy;
					for (int tt = yy = xx = 0; tt < nn[nm]; tt++)
						if (v[nm][tt].zn == 'o')
						{
							if (yy == j) j = tt;
							yy++;
						}
						else
						{
							if (xx == i) i = tt;
							xx++;
						}

					if ("возможна аннигиляция одного вихря", 421) // erro 421

					if (rrr(v[nm][i].x,v[nm][i].y,v[nm][j].x,v[nm][j].y) <= DS)
					{
						e0 = -(v[nm][i].e + v[nm][j].e);

						swapvi(v[nm],i,nn[nm] - 1);
						e0 = e0 - eone3(v[nm],nn[nm]);

						v[nm] = realloc(v[nm], nn[nm] * sizeof(struct vortex));
						nn[nm]--;

						swapvi(v[nm],(j == nn[nm]) ? i : j,nn[nm] - 1);
						e0 = e0 - eone3(v[nm],nn[nm]);

						v[nm] = realloc(v[nm], nn[nm] * sizeof(struct vortex));
						nn[nm]--;
					}
				}
				break;
			default: // перемещение
				i = rand() % nn[nm];

				do {
					x = (double)rand() / RAND_MAX * 2 * DP * v[nm][i].l - DP * v[nm][i].l;
					y = (double)rand() / RAND_MAX * 2 * DP * v[nm][i].l - DP * v[nm][i].l;
				} while (x * x + y * y > DP * v[nm][i].l);
#if XG == 1
				if (v[nm][i].x + x < 0)
					break;
				else
					if (v[nm][i].x + x >= X)
						break;
					else
						x = v[nm][i].x + x;
#else
				x = (v[nm][i].x + x < 0) ? (X + v[nm][i].x + x) : ((v[nm][i].x + x >= X) ? (v[nm][i].x + x - X) : (v[nm][i].x + x));
#endif
#if YG == 1
				if (v[nm][i].y + y < 0)
					break;
				else
					if (v[nm][i].y + y >= Y)
						break;
					else
						y = v[nm][i].y + y;
#else
				y = (v[nm][i].y + y < 0) ? (Y + v[nm][i].y + y) : ((v[nm][i].y + y >= Y) ? (v[nm][i].y + y - Y) : (v[nm][i].y + y));
#endif
				if (check(v[nm],nn[nm],x,y)) break;


				swapvi(v[nm],i,nn[nm] - 1);

				e0 = eone3(v[nm],nn[nm]) + v[nm][nn[nm] - 1].e;
				t = v[nm][nn[nm] - 1].t; v[nm][nn[nm] - 1].t = temp(x,y);
				h = v[nm][nn[nm] - 1].h; v[nm][nn[nm] - 1].h = pole(x,y);
				g = v[nm][nn[nm] - 1].x; v[nm][nn[nm] - 1].x = x; x = g;
				g = v[nm][nn[nm] - 1].y; v[nm][nn[nm] - 1].y = y; y = g;
				l = v[nm][nn[nm] - 1].l; v[nm][nn[nm] - 1].l = lamb(v[nm][nn[nm] - 1].t);
				xi = v[nm][nn[nm] - 1].xi; v[nm][nn[nm] - 1].xi = ksii(v[nm][nn[nm] - 1].t);
				g = v[nm][nn[nm] - 1].e; v[nm][nn[nm] - 1].e = ((v[nm][nn[nm] - 1].zn == 'o') ? 1 : -1) * e1(v[nm][nn[nm] - 1].h,v[nm][nn[nm] - 1].l,v[nm][nn[nm] - 1].x,v[nm][nn[nm] - 1].y) + e2(v[nm][nn[nm] - 1].l,v[nm][nn[nm] - 1].xi) + eone4(v[nm],nn[nm] - 1);
				e0 = eone3(v[nm],nn[nm]) + v[nm][nn[nm] - 1].e - e0;
				if (e0 > 0)
				{
					if ((double)rand() / RAND_MAX > (double)exp(-e0 / v[nm][nn[nm] - 1].t))
					{
						e0 = 0;
						v[nm][nn[nm] - 1].x = x;
						v[nm][nn[nm] - 1].y = y;
						v[nm][nn[nm] - 1].t = t;
						v[nm][nn[nm] - 1].h = h;
						v[nm][nn[nm] - 1].l = l;
						v[nm][nn[nm] - 1].xi = xi;
						v[nm][nn[nm] - 1].e = g;
					}
				}

				// скорость
				// шаг : вектор расстояния : расстояние x : расстояние y : координата x : координата y
				if (nm >= 1000) fprintf(fsp, "%d %.8f %.8f %.8f %.8f %.8f\n", nm, rrr(v[nm][nn[nm] - 1].x,v[nm][nn[nm] - 1].y,x,y), m(v[nm][nn[nm] - 1].x - x), m(v[nm][nn[nm] - 1].y - y), v[nm][nn[nm] - 1].x, v[nm][nn[nm] - 1].y);
		}
	}
	stopr(e0);
	pthread_exit(0);
}


/* --- */


/* распределяет в системе примеси */
void *defect() {
	int i;
	double w = 1.32471795724474602596, a1, a2, xi, yi;

	a1 = 1.0 / w;
	a2 = 1.0 / (w * w);

	pr = malloc(NP * sizeof(struct prim));
	for (i = 0; i < NP; i++)
	{
		pr[i].x = ((double)rand() - (double)rand()) / RAND_MAX * RP;
		pr[i].y = ((double)rand() - (double)rand()) / RAND_MAX * RP;
		w = ((0.5 + a1 * i) - (int)(0.5 + a1 * i));
		pr[i].x = ((pr[i].x + w > 1) ? (pr[i].x + w - 1) : ((pr[i].x + w < 0) ? (pr[i].x + w + 1) : (pr[i].x + w))) * X;
		w = ((0.5 + a2 * i) - (int)(0.5 + a2 * i));
		pr[i].y = ((pr[i].y + w > 1) ? (pr[i].y + w - 1) : ((pr[i].y + w < 0) ? (pr[i].y + w + 1) : (pr[i].y + w))) * Y;
		pr[i].u = (double)rand() / RAND_MAX * m(U01 - U02) + U02;
	}
}


/* принимает значения по ключам при вызове программы */
void take(int argc, char *argv[]) {
	double f, s, t;
	int i, j, x, y, p, q;

	v = malloc(sizeof(struct vortex *));
	v[0] = malloc(sizeof(struct vortex));
	nn = malloc(sizeof(int));
	v[0][0].zn = 'o';

	for (i = 1; i < argc; i++)
	{
		// todo: help
		if ((argv[i][0] == '-' && argv[i][1] == 'h' && argv[i][2] == 'e' && argv[i][3] == 'l' && argv[i][4] == 'p' && argv[i][5] == '\0') || (argv[i][0] == '-' && argv[i][1] == '-' && argv[i][2] == 'h' && argv[i][3] == 'e' && argv[i][4] == 'l' && argv[i][5] == 'p' && argv[i][6] == '\0') || (argv[i][0] == 'h' && argv[i][1] == 'e' && argv[i][2] == 'l' && argv[i][3] == 'p' && argv[i][4] == '\0')) // help
		{
			printf("используются следующие ключи:\
				\n  -d    -- для задания начальной конфигурации расположения вихрей\
				\n  -p    -- для задания начальной конфигурации расположения примесей\
				\n  -help -- для выхова этой справки\
				\n");

			erro("запрошен help", 0); // erro 0
		}
		if (argv[i][0] == '-' && argv[i][1] == 'd' && argv[i][2] == '\0') // вихри
		{
			i++; y = x = p = j = 0;
			while (argv[i][j] != '\0' && argv[i][j] != '|')
			{
				if (argv[i][j] == '-')
					if (y == 0 || y == 2)
					{
						x = 1;
						j++;
						continue;
					}
					else erro("минус в неожиданом месте", 3); // erro 3
				if (argv[i][j] == '.')
					if (!p) {p = 1; j++; continue;}
					else erro("слишком много точек во вводе", 1); // erro 1
				if (argv[i][j] == 'x') {v[nm][nn[nm]].zn = 'x'; j++; continue;}
				if ('0' <= argv[i][j] && '9' >= argv[i][j])
				{
					if (y == 0) y = 1;
					if (y == 1)
						if (p)
						{
							v[nm][nn[nm]].x = v[nm][nn[nm]].x + (argv[i][j] - '0') * pow(10,-p);
							p++;
						}
						else
							v[nm][nn[nm]].x = 10 * v[nm][nn[nm]].x + argv[i][j] - '0';
					if (y == 2) y = 3;
					if (y == 3)
						if (p)
						{
							v[nm][nn[nm]].y = v[nm][nn[nm]].y + (argv[i][j] - '0') * pow(10,-p);
							p++;
						}
						else
							v[nm][nn[nm]].y = 10 * v[nm][nn[nm]].y + argv[i][j] - '0';
				}
				else
				{
					if (y == 3)
					{
						if (x) v[nm][nn[nm]].y = -v[nm][nn[nm]].y;
						p = x = y = 0;

						nn[nm]++;
						v[nm] = realloc(v[nm], (nn[nm] + 1) * sizeof(struct vortex));
						v[nm][nn[nm]].x = 0;
						v[nm][nn[nm]].y = 0;
						v[nm][nn[nm]].zn = 'o';
					}
					if (y == 1)
					{
						y = 2;
						if (x) v[nm][nn[nm]].x = -v[nm][nn[nm]].x;
						p = x = 0;
					}
				}
				j++;
			}
		}
		// todo:
		// if (argv[i][0] == '-' && argv[i][1] == 'p' && argv[i][2] == '\0') // примеси
		// {
		// }
	}
	nm++;
	v = realloc(v, (nm + 1) * sizeof(struct vortex*));
	v[nm] = malloc(nn[nm - 1] * sizeof(struct vortex));
	nn = realloc(nn, (nm + 1) * sizeof(int));
	nn[nm] = nn[nm - 1];
	for (i = 0; i < nn[nm]; i++)
	{
		v[nm][i].x = v[nm - 1][i].x;
		v[nm][i].y = v[nm - 1][i].y;
		v[nm][i].zn = v[nm - 1][i].zn;
		v[nm][i].t = v[nm - 1][i].t = temp(v[nm][i].x,v[nm][i].y);
		v[nm][i].h = v[nm - 1][i].h = pole(v[nm][i].x,v[nm][i].y);
		v[nm][i].l = v[nm - 1][i].l = lamb(v[nm][i].t);
		v[nm][i].xi = v[nm - 1][i].xi = ksii(v[nm][i].t);
		v[nm][i].e = v[nm - 1][i].e = ((v[nm][i].zn == 'o') ? 1 : -1) * e1(v[nm][i].h,v[nm][i].l,v[nm][i].x,v[nm][i].y) + e2(v[nm][i].l,v[nm][i].xi) + eone4(v[nm],i);
	}
}


/* --- */


/* |vvv| */
/* печатает файл с местоположением примесей */
void *primes() {
	FILE *rpim;

	rpim = fopen("prim.txt", "w");
	for (int i = 0; i < NP; i++)
		fprintf(rpim, "%.16f;%.16f\n", pr[i].x, pr[i].y);

	fflush(rpim);
	fclose(rpim);
}

// todo: подумать над разбиением (сделать нормировку по размеру)
/* печатает файл с распределением температуры (T) в системе */
void *pritemp() {
	unsigned long long ex = 2500,	// количество разбиений системы по направлению X
		      ey = 2500;	// количество разбиений системы по направлению Y
	int i, j;
	double x = X / (2 * ex), dx = X / ex, y = Y / (2 * ey), dy = Y / ey;
	FILE *etem;

	etem = fopen("T.txt", "w");
	for (i = 0; i <= ex; i++)
	{
		for (j = 0; j <= ey; j++)
			fprintf(etem, "%.12f ", temp(x + dx * i,y + dy * j));
		fprintf(etem, "\n");
	}
	fflush(etem);
	fclose(etem);
}

// todo: подумать над разбиением (сделать нормировку по размеру)
void *pripole() {
	unsigned long long ex = 2500,	// количество разбиений системы по направлению X
		      ey = 5000;	// количество разбиений системы по направлению Y
	int i, j;
	double x = X / (2 * ex), dx = X / ex, y = Y / (2 * ey), dy = Y / ey;
	FILE *epole;

	epole = fopen("H.txt", "w");
	for (i = 0; i <= ex; i++)
	{
		for (j = 0; j <= ey; j++)
			fprintf(epole, "%.12f ", pole(x + dx * i,y + dy * j));
		fprintf(epole, "\n");
	}
	fflush(epole);
	fclose(epole);
}

// todo: подумать над разбиением (сделать нормировку по лямбде?)
// todo: подумать учётом температуры
/* печатает файл с энергией взаимодействия вихрь-вихрь (E3) от расстояния и соответвтующую лямбду */
void *pri3() {
	// r,E3
	int i;
	double l = 10 * L0;
	double pd = l / 10000;
	FILE *e3e3;

//#define T	(x / X * 59.0 + 1) / 11606	// T	: K
	e3e3 = fopen("E3.txt", "w");
	fprintf(e3e3, "%.12f\n", l);
	for (i = 0; i < 10000; i++)
//		fprintf(e3e3, "%.16f %.16f %.16f\n", pd * i, e3(pd * i, lamb(1.0 / 11606)) + e3(pd * i, lamb((pd * i / l * 59.0 + 1) / 11606)), e3(pd * i, lamb((pd * i / l * 59.0 + 2) / 11606 / 2)) + e3(pd * i, lamb((pd * i / l * 59.0 + 2) / 11606 / 2)));
		fprintf(e3e3, "%.16f %.16f %.16f\n", pd * i, e3(pd * i, lamb((1.0 + pd * i / l) / 11606)) + e3(pd * i, lamb(60.0 / 11606)), e3(pd * i, lamb((61.0 + pd * i / l) / 11606 / 2)) + e3(pd * i, lamb((61.0 + pd * i / l) / 11606 / 2)));

	fflush(e3e3);
	fclose(e3e3);
}

/* печатает файл с собственной энергией вихря (E2) от температуры */
void *pri2() {
	int i;
	double pd = 84.0 / 10000;
	FILE *e2e2;

	e2e2 = fopen("E2.txt", "w");
	for (i = 0; i < 10000; i++)
		fprintf(e2e2, "%.16f;%.16f\n", pd * i / 11606, e2(lamb(pd * i / 11606), ksii(pd * i / 11606)));

	fflush(e2e2);
	fclose(e2e2);
}

//todo:
/* печатает файл с собственной энергией вихря (E2) от температуры */
void *pri4() {
	int i;
	double pd = 84.0 / 10000;
	FILE *e4e4;

	e4e4 = fopen("E4.txt", "w");
//	for (i = 0; i < 10000; i++)
//		fprintf(e1e1, "%.16f;%.16f\n", pd * i / 11606, 2 * e4(r, ksii(pd * i / 11606), 1.0));

	fflush(e4e4);
	fclose(e4e4);
}

#define COPR	5
// использование:	pri(сколько будет печатей, что печатать, ...)
/* быстрый запуск необходимых функций для печати разного рода файлов с энергиями, разбиение для энергий берётся как от **ee */
void pri(int count, ...) {
	char ii[COPR];
	int i, c;
	va_list fa;
	pthread_t te[COPR];

	for (i = 0; i < COPR; i++)
		ii[i] = 0;

	va_start(fa, count);
	for (i = 0, c = va_arg(fa, int); i < count; i++, c = va_arg(fa, int))
		switch (c)
		{
			case '3':
				ii[0] = 1;
				pthread_create(&te[0], NULL, pri3, NULL);
				break;
			case 'p':
				ii[1] = 1;
				pthread_create(&te[1], NULL, primes, NULL);
				break;
			case 't':
				ii[2] = 1;
				pthread_create(&te[2], NULL, pritemp, NULL);
				break;
			case 'h':
				ii[3] = 1;
				pthread_create(&te[3], NULL, pripole, NULL);
				break;
			case '2':
				ii[4] = 1;
				pthread_create(&te[4], NULL, pri2, NULL);
				break;
			case '4':
				ii[5] = 1;
				pthread_create(&te[5], NULL, pri4, NULL);
				break;
			default:
				erro("такого ключа нет", 19); // erro 19
		}
	va_end(fa);

	for (i = 0; i < COPR; i++)
		if (ii[i]) pthread_join(te[i],NULL);
}




int main(int argc, char *argv[]) {
	int i, j, x, y, p, q;
	double f = 0, s, g, fs = 0;
	unsigned long long dk = 0;
	pthread_t th[3];

//	pri(1,'3');
//	return 0;

	/*
	for (i = 0; i < 101; i++)
	{
		ue40[i] = -m1 * hc / 400 * ue40[i];
		ue60[i] = -m1 * hc / 400 * ue60[i];
		ue80[i] = -m1 * hc / 400 * ue80[i];
		uec[i] = -m1 * hc / 400 * uec[i];
	}

	FILE *line;
	line = fopen("aline.txt", "w");
	for (i = 0; i <= 1000; i++)
//		fprintf(line, "%.8f %.16f\n", (double)i / 1000 * X, 400 * cosh(((double)i / 1000 * X - X / 2) / lamb(temp((double)i / 1000 * X,Y / 2))) / cosh(DD / (2 * lamb(temp((double)i / 1000 * X,Y / 2)))));
		fprintf(line, "%.8f %.16f %.16f\n", (double)i / 1000 * X, e1(400,lamb(temp((double)i / 1000 * X,Y / 2)),(double)i / 1000 * X,Y / 2), e1_old(400,lamb(temp((double)i / 1000 * X,Y / 2)),(double)i / 1000 * X,Y / 2));
	return 0;
	*/

	/*
	FILE *line;
	line = fopen("aline.txt", "w");
	for (i = 0; i <= 1000; i++)
	{
		fprintf(line, "%.8f %.16f\n", (double)i / 1000 * X, e1_old(600,lamb(temp((double)i / 1000 * X,Y / 2)),(double)i / 1000 * X,Y / 2));
	}
	fclose(line);
	return 0;
	*/

	/*
	FILE *line;
	line = fopen("aline.txt", "w");
	for (i = 0; i <= 1000; i++)
	{
#if XG == 1
		s = -e3(rrb((double)i / 1000 * X,Y / 2,-(double)i / 1000 * X,Y / 2),lamb(temp((double)i / 1000 * X,Y / 2)));

		s = s - e3(rrb((double)i / 1000 * X,Y / 2,2 * X - (double)i / 1000 * X,Y / 2),lamb(temp((double)i / 1000 * X,Y / 2)));
#endif
#if YG == 1
		s = -e3(rrb((double)i / 1000 * X,Y / 2,(double)i / 1000 * X,-Y / 2),lamb(temp((double)i / 1000 * X,Y / 2)));

		s = s - e3(rrb((double)i / 1000 * X,Y / 2,2 * X - (double)i / 1000 * X,Y / 2),lamb(temp((double)i / 1000 * X,2 * Y - Y / 2)));
#endif
		fprintf(line, "%.8f %.16f %.16f %.16f\n", (double)i / 1000 * X, e1(400,lamb(temp((double)i / 1000 * X,Y / 2)),(double)i / 1000 * X,Y / 2), e2(lamb(temp((double)i / 1000 * X,Y / 2)),ksii(temp((double)i / 1000 * X,Y / 2))), s);
	}
	fclose(line);
	return 0;
	*/


//	geex = fopen("g_T.txt", "a+t");
//	fprintf(geex, "%.1f:", T * 11606);
//
//	out2 = fopen("gex.txt", "w");
	/* --- */
	// printf("угол: %.3f\n", ugol(0, 0, 1, -1, 1, 0));
	// exit(0);

	// srand(clock());

	// take(argc,argv);

	// e = malloc(2 * sizeof(double));
	// e[1] = e[0] = tote1(v[nm],nn[nm]) + tote2(v[nm],nn[nm]) + tote3(v[nm],nn[nm]) + tote4(v[nm],nn[nm]);

	// int i, j;
	// double x, y;
	// char zn;
	// for (i = 0; i < 10; i++)
	// {
	// 	zn = 'o';

	// 	x = (double)rand() / RAND_MAX * X;
	// 	y = (double)rand() / RAND_MAX * Y;

	// 	//y = 0.0004;
	// 	//x = 0.00025;

	// 	if (check(v[nm],nn[nm],x,y)) {--i; continue;}

	// 	v[nm] = realloc(v[nm], (nn[nm] + 1) * sizeof(struct vortex));

	// 	v[nm][nn[nm]].x = x;
	// 	v[nm][nn[nm]].y = y;
	// 	v[nm][nn[nm]].zn = zn;
	// 	v[nm][nn[nm]].t = temp(x,y);
	// 	v[nm][nn[nm]].h = pole(x,y);
	// 	v[nm][nn[nm]].l = lamb(v[nm][nn[nm]].t);
	// 	v[nm][nn[nm]].xi = ksii(v[nm][nn[nm]].t);
	// 	v[nm][nn[nm]].e = ((v[nm][nn[nm]].zn == 'o') ? 1 : -1) * e1(v[nm][nn[nm]].h,v[nm][nn[nm]].l,v[nm][nn[nm]].x,v[nm][nn[nm]].y) + e2(v[nm][nn[nm]].l,v[nm][nn[nm]].xi) + eone4(v[nm],nn[nm]);

	// 	nn[nm] = nn[nm] + 1;
	// }

	// printf("> %.16f\n", gex(v[nm],nn[nm],L0));

	// snprintf(ss, 512, "coordinat.txt");
	// FILE *out;

	// out = fopen(ss, "w");
	// fprintf(out, "δE = %.4f эВ\n* : %.16f\n", m(pog * e[nm]), e[0]);
	// for (i = 0; i < nn[0]; i++)
	// 	fprintf(out, "%c(%.8f;%.8f) ", v[0][i].zn, v[0][i].x, v[0][i].y);
	// fprintf(out, "\n");
	// for (i = 1; i <= nm; i++)
	// {
	// 	fprintf(out, "%lld : %.16f\n", (unsigned long long)i, e[i]);
	// 	for (j = 0; j < nn[i]; j++)
	// 		fprintf(out, "%c(%.8f;%.8f) ", v[i][j].zn, v[i][j].x, v[i][j].y);
	// 	fprintf(out, "\n");
	// }
	// fflush(out);
	// fclose(out);

	// exit(0);

	/* --- */

	for (i = 0; i < 101; i++)
	{
		ue40[i] = -m1 * hc / 400 * ue40[i];
		ue60[i] = -m1 * hc / 400 * ue60[i];
		ue80[i] = -m1 * hc / 400 * ue80[i];
		uec[i] = -m1 * hc / 400 * uec[i];
		uec40[i] = -m1 * hc / 400 * uec40[i];
		uec60[i] = -m1 * hc / 400 * uec60[i];
		uec80[i] = -m1 * hc / 400 * uec80[i];
	}


	// скорость
	fsp = fopen("T60d18/speed.txt", "w");


//	printf("%.16f -- %.16f | %.6f %.2f | %.6f %.2f | %19.16f | %d\n", uec[(int)((x / X) * 100)] * he, E1Y, x, x / X, y, y / Y, uec[(int)((x / X) * 100)] * he - E1Y, nm);

// 	printf("+\n");

//  	FILE *outn;
//  	outn = fopen("a.txt", "w");
//  	for (i = 0; i <= 10000; i++)
// //		fprintf(outn, "%.8f\n", (double)i / (10000) * X);
//  		fprintf(outn, "%.8f %.16f %.16f\n", (double)i / 10000 * X, uec[(int)(((double)i / 10000) * 100)] * he, e1(he,lamb(T),(double)i / 10000 * X,Y / 2));
//  	exit(0);


//	sp = malloc(sizeof(double));
//	spx = malloc(sizeof(double));
//	spy = malloc(sizeof(double));
//	sp[0] = 0; spx[0] = 0; spy[0] = 0;


//	pri(1,'4');
//	exit(0);
//	printf("%.16f\n%.16f\n%.16f\n", temp(0,0) * 11606, temp(0.00025,0.00025) * 11606, temp(0.0005,0.0005) * 11606);
//	exit(0);

//	printf(">> %.16f\n>> %.16f\n", m1 * 400, e1(400,L0,0.00025,0.00050));
//	exit(0);

	// генератор случайного
	srand(clock());


	//
//	FILE *stemp;
//
//	stemp = fopen("stemp2.txt", "w");
//	for (s = 0; s < Y; s = s + 0.0001 * Y)
//		fprintf(stemp, "%.8f:%.16f\n", s, e1(pole(X / 2, s), lamb(temp(X / 2, s)), X / 2, s));
//	return 0;
	//


	// примеси
       pthread_create(&th[0], NULL, defect, NULL);
       pthread_join(th[0],NULL);


	// ввод из коммандной строки
	take(argc,argv);


//	struct vortex *a;
//	for (i = 0; i < 20; i++)
//	{
//		a = new(v[nm],&nn[nm]);
//		if (!a) break;
//		v[nm] = a;
//	}

	// печать всякой фигни
	pri(2,'p','t');


	// начальная энергия
	e = malloc(2 * sizeof(double));
	e[1] = e[0] = tote1(v[nm],nn[nm]) + tote2(v[nm],nn[nm]) + tote3(v[nm],nn[nm]) + tote4(v[nm],nn[nm]);


#if D < 0
	if (nn[nm] > 4) d = nn[nm];
	else d = DM;
#endif

	// основной цикл
S:	while (!kbhit())
	{
		pthread_create(&th[0], NULL, three, NULL);
		pthread_join(th[0],NULL);

		if (qqq) goto E;
	}
	switch (getch())
	{
		case 's':
			show();
			goto S;
		case 'q':
			// todo: сделать сохранение посчитоного до следующего програмного шага
			break;
		case 'p':
			// todo: сделать паузу, скушать твикс
			goto S;
		case 'i':
			// todo: сделать сохранение
			goto S;
		default:
			goto S;
	}

E:
	show();

	// параметр гексагональности
//	printf("параметр гексагональности: %.16f\n", gex(v[nm],nn[nm],L0));
//
//	fprintf(geex, "\n");


	return 0;
}
